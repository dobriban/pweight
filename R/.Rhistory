w_1 = KKT_Weights(mu)
# This code computes weights for p-values via the KKT heuristic
# of Owen & Dobriban;
# given estimated means of test statistics, the weighting scheme optimizes
# the expected number of discoveries at some specific level alpha
#
# inputs:
# mu - a non-positive vector of length J, the estimated means of test statistics
# alpha - level at which the number of discoveries should be maximized
KKT_Weights = function(mu, alpha = 0.001) {
J = length(mu)
ind = order(mu)
mu = sort(mu)
weights = pnorm(mu/2)
c = 0
K = 0
while((c <= J*alpha) && (K<J)) {
K = K+1
c = c + weights[K]
}
if (K>0) {
K = K-1
}
weights[K+1:length(weights)] = 0
w = rep(0,J)
for (i in (1:J)) {
w[ind[i]] = weights[i]
}
w = w/alpha
return(w)
}
J = 100
mu = -abs(rnorm(J))
alpha = 0.05
#find weights
w_1 = KKT_Weights(mu)
plot(mu,w_1)
# generate means
J = 2000
mu = -abs(rnorm(J))
sigma = 1*rep(1,J)
alpha = 1/J
w_1 = bayes_weights(mu,sigma, alpha)
ls
cd
w_1 = bayes_weights(mu,sigma, alpha)
getwd
getwd()
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r")
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/Code")
w_1 = bayes_weights(mu,sigma, alpha)
getwd()
w_1 = bayes_weights(mu,sigma, alpha)
getwd()
ls()
# Edgar Dobriban
# this code computes the Roeder-Wasserman weights for p-value weighting
# given means of test statistics, the weighting scheme optimizes
# the expected number of discoveries at some specific level q
#
# inputs:
# mu - a non-positive vector of length J, the estimated means of test statistics
# q - level at which the number of discoveries should be maximized;
#        J*q is the number of expected false rejections, typically a constant
#        even if the problem size grows
spjotvoll_weights = function(mu, q) {
J = length(mu)
#define the functions used by Newton's method
#the goal is to find the zero of the function f below
f <- function(c) 1/J*sum(pnorm(c/mu+mu/2))-q;
df <- function(c) 1/J*sum(dnorm(c/mu+mu/2)/mu);
x0 = 0;
tol = 1e-3/J;
nmax = 100;
x = rep(0,nmax)
ex = rep(0,nmax)
#Newton's method iterations
x[1] = x0 - (f(x0)/df(x0));
ex[1] = abs(x[1]-x0);
k = 2;
while ((ex[k-1] >= tol) && (k <= nmax)) {
x[k] = x[k-1] - (f(x[k-1])/df(x[k-1]));
ex[k] = abs(x[k]-x[k-1]);
k = k+1;
}
c = x[k-1]; #could return this
w = pnorm(c/mu+mu/2)/q;
return(w)
}
# Edgar Dobriban
# this code computes the regularized weights for p-value weighting
# of Owen & Dobriban;
# given estimated means and standard errors of test statistics, the weighting scheme optimizes
# the expected number of discoveries at some specific level q
#
# inputs:
# mu - a non-positive vector of length J, the estimated means of test statistics
# sigma - a positive vector of length J, the estimated standard errors of test statistics
# q - level at which the number of discoveries should be maximized;
#        J*q is the number of expected false rejections, typically a constant
#        even if the problem size grows
bayes_weights = function(mu, sigma, q) {
J = length(mu)
# define auxiliary variables
var_plus = sigma^2+1
var = sigma^2
mu2 = mu^2
alpha = mu/var
beta = (mu2 + var*(mu2+var_plus*log(var_plus)))/(var^2)
gamma = 2*var_plus/var
#define the functions used by Newton's method
#the goal is to find the zero of the function f below
f <- function(c) 1/J*sum(pnorm(-alpha - sqrt(beta + gamma*c)))-q;
df <- function(c) 1/J*sum(-dnorm(-alpha - sqrt(beta + gamma*c))*gamma*(beta + gamma*c)^(-1/2));
x0 = 0;
tol = 1e-3/J;
nmax = 100;
x = rep(0,nmax)
ex = rep(0,nmax)
#Newton's method iterations
x[1] = x0 - (f(x0)/df(x0));
ex[1] = abs(x[1]-x0);
k = 2;
while ((ex[k-1] >= tol) && (k <= nmax)) {
x[k] = x[k-1] - (f(x[k-1])/df(x[k-1]));
ex[k] = abs(x[k]-x[k-1]);
k = k+1;
}
c = x[k-1]; #could return this
w = pnorm(-alpha - sqrt(beta + gamma*c))/q;
return(w)
}
w_1 = bayes_weights(mu,sigma, alpha)
plot(mu,w_1)
for (j in (1:4)) {
alpha = 2^j/J
w_1 = bayes_weights(mu,sigma, alpha)
plot(mu,w_1)
}
plot(mu,w_1)
plot(mu,w_1)
library
library()
help(sqrt)
plot(t$a, type="l", ylim=range(t),
2 lwd=3, col=rgb(1,0,0,0.3))
plot(t$a, type="l", ylim=range(t),lwd=3, col=rgb(1,0,0,0.3))
plot(t=rnorm(100), type="l", ylim=range(t),lwd=3, col=rgb(1,0,0,0.3))
t = rnorm(100)
plot(t, type="l", ylim=range(t),lwd=3, col=rgb(1,0,0,0.3))
plot(t, type="l", ylim=range(t),lwd=3, col=rgb(1,0,0,0.8))
plot(t, type="l", ylim=range(t),lwd=3, col=rgb(1,0,0,1.1))
points(t, pch=20, cex=4,col=rgb(0,0,1,0.3))
points(t, pch=20, cex=4,col=rgb(0,0,1,0.3))
points(t, pch=2, cex=4,col=rgb(0,0,1,0.3))
points(t, pch=1, cex=4,col=rgb(0,0,1,0.3))
points(t, pch=6, cex=4,col=rgb(0,0,1,0.3))
points(t, pch=6, cex=1,col=rgb(0,0,1,0.3))
points(t, pch=6, cex=10,col=rgb(0,0,1,0.3))
d = data.frame(a = c(3,4,5), b = c(12,43,54))
View(d)
write.table(d, file="tst0.txt") #,row.names=FALSE)
d2 = read.table(file="tst0.txt")#, header=TRUE)
View(`d2`)
d2
d1-d2
d-d2
d2 = read.table(file="tst0.txt", header=FALSE)
install.packages("formatR")
formatR::tidy_dir("R")
ls()
getwd()
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
clear
cls
clear
formatR::tidy_dir("R")
var_plus = sigma^2 + 1
tempdir()
J = 2000
mu = -abs(rnorm(J))
sigma = 1 * rep(1, J)
alpha = 1/J
# find weights
w_1 = bayes_weights(mu, sigma, alpha)
w_1 = bayes_weights(mu, sigma, alpha)
getwd()
ans
"ans"
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
ls
ls()
w_1 = bayes_weights(mu, sigma, alpha)
getwd()
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
source("bayes_weights.R")
source("bayes_weights.R")
w_1 = bayes_weights(mu, sigma, alpha)
plot(mu, w_1)
plot(mu, w_1)
for (j in (1:4)) {
alpha = 2^j/J
w_1 = bayes_weights(mu, sigma, alpha)
plot(mu, w_1)
}
w_1 <- bayes_weights(mu, sigma, alpha)
source("bayes_weights.R")
J <- 200
mu <- -abs(rnorm(J))
sigma <- 1 * rep(1, J)
alpha <- 10
# find weights
w_1 <- bayes_weights(mu, sigma, alpha)
q <- 10
var_plus <- sigma^2 + 1
var <- sigma^2
mu2 <- mu^2
alpha <- mu / var
beta <- (mu2 + var * (mu2 + var_plus * log(var_plus))) / (var^2)
gamma <- 2 * var_plus / var
f <- function(c) 1 / J * sum(pnorm(-alpha - sqrt(beta + gamma * c))) - q;
df <- function(c) 1 / J * sum(-dnorm(-alpha - sqrt(beta + gamma * c)) * gamma * (beta + gamma * c)^(- 1 / 2));
if (f(0) >=0) { #Newton
}
f(0)
gamma <- sqrt(var_plus)
e(2)
exp(2)
mu <- -1
gamma <-2
f <- function(x) 1 - exp(x) - (pnorm((c_1(eta, gamma, x, 1) - eta) / gamma)
- exp(x) * pnorm(c_1(eta, gamma, x, 1)))
log_l <-  - log(gamma)  - eta^2 / (2 * (gamma^2 - 1))
eta <- mu
f <- function(x) 1 - exp(x) - (pnorm((c_1(eta, gamma, x, 1) - eta) / gamma)
- exp(x) * pnorm(c_1(eta, gamma, x, 1)))
log_l <-  - log(gamma)  - eta^2 / (2 * (gamma^2 - 1))
f(log_l)
end
c_1(eta,gamma,0,1)
source("c_1.R")
source("c_1.R")
cat("Current working dir: ", getwd())
cat("Current working dir: ", lambda)
lambda = 1
cat("Current working dir: ", lambda)
source("c_1.R")
source("c_1.R")
source("c_1.R")
c_1(eta,gamma,0,1)
x <- c_1(eta, gamma, 0, 1)
x
f <- function(x) 1 - exp(x) - (pnorm((c_1(eta, gamma, x, 1) - eta) / gamma)
- exp(x) * pnorm(c_1(eta, gamma, x, 1)))
log_l <-  - log(gamma) - eta^2 / (2 * (gamma^2 - 1))
f(log_l)
x0 <- c(log_l, 0) #initial interval
x <- uniroot(f, x0)
lambda <- exp(x)
x0
x
x$root
lambda <- exp(x$root)
return(lambda)
gamma <- sqrt(var_plus)
J <- 200
mu <- -abs(rnorm(J))
sigma <- 1 * rep(1, J)
q <- 10
gamma <- sqrt(var_plus)
length(mu)
gamma <- sqrt(var_plus)
source("find_crossing.R")
for (i in 1:J) {
l_prime[i] <- find_crossing(mu[i],gamma[i])
}
l_prime <- rep(0, J)
for (i in 1:J) {
l_prime[i] <- find_crossing(mu[i],gamma[i])
}
plot(l_prime)
plot(l_prime)
plot(mu,l_prime)
sort(l_prime)
l_sort <-sort(l_prime)
ind<order(l_prime)
ind<-order(l_prime)
l_prime(ind[1])-l_sort[1]
l_prime[ind[1]]-l_sort[1]
%
source("g_fun.R")
H <- function(lambda) sum(g_fun(mu, gamma, lambda, l_prime))
plot(H)
plot(H, from=-1,to=1)
plot(H, from=0,to=1)
a = g_fun(mu, gamma, lambda, l_prime)
a = g_fun(mu, gamma, lambda, l_prime)
source("g_fun.R")
a = g_fun(mu, gamma, lambda, l_prime)
lambda
plot(mu,a)
plot(mu,a)
plot(mu,mu)
plot(mu,a)
plot(l_prime,a)
plot(mu,l_prime)
plot(mu,sigma)
a = g_fun(mu, gamma, lambda, l_prime)
plot(mu,a)
plot(mu,l_prime)
a <- g_fun(mu, gamma, lambda, l_prime)
g_fun(mu[1],gamma[1],lambda, l_prime[1])
a g_fun(mu[1],gamma[1],lambda, l_prime[1])
a <- g_fun(mu[1],gamma[1],lambda, l_prime[1])
a
source("g_fun.R")
a <- g_fun(mu[1],gamma[1],lambda, l_prime[1])
a
eta <- mu
J  <- length(eta)
g_fun <- rep(0, J)
for (i in 1:J) {
if (lambda <= l_prime[i]) {
g_fun[i] <- 1
} else{
g_fun[i] <- pnorm(Re(c_1(eta[i], gamma[i], lambda)))
}
}
source("g_fun.R")
a <- g_fun(mu[1],gamma[1],lambda, l_prime[1])
a
a <- g_fun(mu, gamma, lambda, l_prime)
plot(mu,a)
l_sort  <- c(l_sort, 1)
l <- 1; u <- J + 1;
help floor
help(floor)
=
q_star <- J*q;
abs(-2)
any(-2>0)
any(-2>-3)
source("bayes_weights.R")
source("bayes_weights.R")
source("bayes_weights.R")
source("bayes_weights.R")
J <- 200
mu <- -abs(rnorm(J))
sigma <- 1 * rep(1, J)
q <- 10
# find weights
w_1 <- bayes_weights(mu, sigma, q)
source("bayes_weights.R")
w_1 <- bayes_weights(mu, sigma, q)
source("bayes_weights.R")
w_1 <- bayes_weights(mu, sigma, q)
source("bayes_weights.R")
w_1 <- bayes_weights(mu, sigma, q)
?warning
warning("testit")
stop("testit")
source("bayes_weights.R")
w_1 <- bayes_weights(mu, sigma, q)
alpha <- 10
# find weights
source("bayes_weights.R")
w_1 <- bayes_weights(mu, sigma, q = alpha/J)
plot(mu,w_1)
alpha <- 50
w_1 <- bayes_weights(mu, sigma, q = alpha/J)
w_1 <- bayes_weights(mu, sigma, q = alpha/J)
plot(mu,w_1)
alpha <- 100
w_1 <- bayes_weights(mu, sigma, q = alpha/J)
plot(mu,w_1)
source("bayes_weights.R")
w_1 <- bayes_weights(mu, sigma, q = alpha/J)
source("bayes_weights.R")
w_1 <- bayes_weights(mu, sigma, q = alpha/J)
plot(mu,w_1$w)
w_1$q_thresh
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
source("exp_weights.R")
# Plots  ----------------
# generate means
J <- 2000
mu <- -abs(rnorm(J))
beta <- 2
alpha <- 1 / J
q <- 0.05
# find weights
w_1 <- exp_weights(mu, beta, q)
gamma>1.2
find(gamma>1.2)
large <- gamma>1.2
sum(gamma[large])
source("exp_weights.R")
w_1 <- exp_weights(mu, beta, q)
w_1 <- exp_weights(mu, beta, q)
# find weights
source("exp_weights.R")
w_1 <- exp_weights(mu, beta, q)
plot(mu, w_1)
beta <- 4
w_1 <- exp_weights(mu, beta, q)
plot(mu, w_1)
mean(w_1)
mean(w_1-1)
q <- 0.5
w_1 <- exp_weights(mu, beta, q)
plot(mu, w_1)
J <- 2000
J <- 2000
# Unit tests for Spjotvoll weights
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
source("bayes_weights.R")
source("spjotvoll_weights.R")
# Plots  ----------------
# generate means
J <- 2000
mu <- -abs(rnorm(J))
sigma <- 0.1 * rep(1, J)
alpha <- 1 / J
# find weights
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
w_2 <- spjotvoll_weights(mu, alpha)
plot(mu, w_2,col="red")
w_1
w_1$w
# Plots  ----------------
# generate means
J <- 2000
mu <- -abs(rnorm(J))
sigma <- 0.1 * rep(1, J)
alpha <- 1 / J
# find weights
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
# Unit tests for Spjotvoll weights
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
source("bayes_weights.R")
source("spjotvoll_weights.R")
# Plots  ----------------
# generate means
J <- 2000
mu <- -abs(rnorm(J))
sigma <- 0.1 * rep(1, J)
alpha <- 1 / J
# find weights
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
w_2 <- spjotvoll_weights(mu, alpha)
plot(mu, w_2,col="red")
# Unit tests for Spjotvoll weights
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
source("bayes_weights.R")
source("spjotvoll_weights.R")
# Plots  ----------------
# generate means
J <- 2000
mu <- -abs(rnorm(J))
sigma <- 0.1 * rep(1, J)
alpha <- 1 / J
# find weights
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
w_2 <- spjotvoll_weights(mu, alpha)
plot(mu, w_2,col="red")
sigma <- 0.1 * rep(1, J)
# Unit tests for Spjotvoll weights
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
source("bayes_weights.R")
source("spjotvoll_weights.R")
# Plots  ----------------
# generate means
J <- 2000
mu <- -abs(rnorm(J))
sigma <- 0.1 * rep(1, J)
alpha <- 1 / J
# find weights
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
w_2 <- spjotvoll_weights(mu, alpha)
plot(mu, w_2,col="red")
source("spjotvoll_weights.R")
# Unit tests for Spjotvoll weights
setwd("C:/Dropbox/Weighted New/pvalue_weighting_r/R")
source("bayes_weights.R")
source("spjotvoll_weights.R")
# Plots  ----------------
# generate means
J <- 2000
mu <- -abs(rnorm(J))
sigma <- 0.1 * rep(1, J)
alpha <- 1 / J
# find weights
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
w_2 <- spjotvoll_weights(mu, alpha)
plot(mu, w_2,col="red")
plot(mu, w_2,col="red", pch=2)
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
w_2 <- spjotvoll_weights(mu, alpha)
lines(mu, w_2,col="red", pch=2)
w_1 <- bayes_weights(mu, sigma, alpha)
plot(mu, w_1$w)
w_2 <- spjotvoll_weights(mu, alpha)
points(mu, w_2,col="red", pch=2)
